---
title: "scLANE_Simulation_Study"
subtitle: "University of Florida Dept. of Biostatistics - The Bacher Group"
author: "Jack Leary"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{scLANE_Simulation_Study}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE, 
  message = FALSE, 
  comment = "#>"
)
```

```{r setup}
library(dplyr)
library(scran)
library(scater)
library(scLANE)
library(ggplot2)
library(scaffold)
library(slingshot)
library(kableExtra)
library(SingleCellExperiment)
select <- dplyr::select
rename <- dplyr::rename
```

# Simulation with `scaffold`

First we'll use [Dr. Ronda Bacher's `scaffold` package](https://github.com/rhondabacher/scaffold/) to simulate scRNA-seq data with trajectories. The practical advantages of `scaffold` are that it bases its simulated data on real datasets, it generates large numbers of cells and features relatively quickly, and it includes an indicator variable that specifies whether genes are differentially expressed. This last feature will allow us to test the performance of `scLANE` with respect to its identification of genes that are dynamic over pseudotime. Let's dive in!

Before all else one must `set.seed()`.

```{r}
set.seed(312)
RcppZiggurat::zsetseed(312)
```

Let's load in some data. We're going to base our simulation on the data from [Baron *et al* (2016)](https://doi.org/10.1016/j.cels.2016.08.011); their dataset is a small-ish single cell atlas of normal pancreas cells.

```{r}
#panc <- readRDS("~/Desktop/panc.Rds")
panc <- scRNAseq::BaronPancreasData()  # uses inDrop, a droplet-based tech
```

And now let's run `scaffold`. We want to generate a UMI-based 10X dataset with 3,000 cells, and `r ceiling(.15 * nrow(panc))` dynamic genes - 15% of the `r nrow(panc)` total genes in the Baron pancreas dataset.

```{r}
n_dyn_genes <- ceiling(.15 * nrow(panc))
myknots <- matrix(runif(2 * n_dyn_genes, 0, 1), ncol = 2, nrow = n_dyn_genes)
mytheta <- matrix(rnorm(5, 5, 5), ncol = 5, nrow = n_dyn_genes)
dynamic_params <- list(propGenes = 0.15,
                       degree = 2,
                       knots = myknots,
                       theta = mytheta)
scaffold_params <- estimateScaffoldParameters(sce = panc,
                                              sceUMI = TRUE,
                                              useUMI = TRUE,
                                              protocol = "droplet",
                                              numCells = 1000,
                                              popHet = c(1, 1),
                                              useDynamic = dynamic_params)
panc_sim <- simulateScaffold(scaffoldParams = scaffold_params, originalSCE = panc)
#panc_sim <- readRDS("~/Desktop/panc_sim.Rds")
```

```{r, echo=FALSE, results='hide'}
rm(panc); gc()
```

# Data Pre-processing 

Next we'll need to pre-process the raw counts in the typical way. 

```{r}
panc_sim <- logNormCounts(panc_sim)
var_decomp <- modelGeneVar(panc_sim)
top2k_hvgs <- getTopHVGs(var_decomp, n = 2000)
panc_sim <- runPCA(panc_sim, subset_row = top2k_hvgs)
reducedDim(panc_sim, "PCAsub") <- reducedDim(panc_sim, "PCA")[, 1:10, drop = FALSE]
panc_sim <- runUMAP(panc_sim, dimred = "PCAsub", n_dimred = 1:10)
g <- buildSNNGraph(panc_sim, use.dimred = "PCAsub", k = 30)
clusters <- igraph::cluster_louvain(graph = g)$membership
colLabels(panc_sim) <- factor(clusters)
plotPCA(panc_sim, colour_by = "label")
plotUMAP(panc_sim, colour_by = "label")
```

# Pseudotime Estimation with `slingshot`

Next we'll estimate trajectories with `slingshot`. We see that there are two lineages, thus we'll need to run the `scLANE` process twice.

```{r}
ss_out <- slingshot(data = panc_sim, 
                    reducedDim = "PCAsub",  
                    clusterLabels = panc_sim$label)
ss_pt <- slingPseudotime(ss_out)
ss_pt %>% 
  head() %>% 
  kbl(digits = 5, booktabs = TRUE) %>% 
  kable_paper(full_width = FALSE)
```

```{r, echo=FALSE, results='hide'}
rm(ss_out); gc()
```

# Identifying Dynamic Genes with `scLANE` 

## Branch 1

We prepare the data from the first branch. 

```{r}
ss_pt_1_scaled <- na.omit(ss_pt[, 1]) / max(na.omit(ss_pt[, 1]))
cells_branch_1 <- rownames(ss_pt)[!is.na(ss_pt[, 1])]
sim_counts_1 <- t(counts(panc_sim[, colnames(panc_sim) %in% cells_branch_1]))
sim_counts_1 <- sim_counts_1[, which(colSums(sim_counts_1) > 0)]
sim_counts_1 <- as.matrix(sim_counts_1)
pt_df_1 <- data.frame(PT = ss_pt_1_scaled)
```

`testDynamic()` fits a `marge` spline-based NB GLM to each gene, using pseudotime as the sole covariate. 

```{r}
gene_stats_1 <- testDynamic(expr = sim_counts_1[, 1:20], 
                            pt = pt_df_1, 
                            genes = colnames(sim_counts_1)[1:20], # [sample(1:ncol(sim_counts_1), 10, replace = FALSE)], 
                            parallel = TRUE, 
                            n.cores = 2, 
                            n.potential.basis.fns = 5, 
                            track.time = TRUE)
```

Let's check the categorization of each gene as dynamic versus the ground truth labels from `scaffold`. 

```{r}
dyn_results_1 <- getResultsDE(gene_stats_1, p.adj.method = "bonferroni", fdr.cutoff = 0.01) %>% 
                 inner_join((rowData(panc_sim) %>% 
                             as.data.frame() %>% 
                             mutate(gene = rownames(.))), by = c("Gene" = "gene"))
```

Next we'll run another test of dynamism (?) with `testSlopes()`. 

```{r}
mod_list_1 <- getModelList(gene_stats_1)
slope_test_1 <- testSlope(model.list = mod_list_1, 
                          pt = pt_df_1, 
                          p.adj.method = "bonferroni", 
                          fdr.cutoff = 0.01)
slope_results_1 <- slope_test_1 %>% 
                   inner_join((rowData(panc_sim) %>% 
                               as.data.frame() %>% 
                               mutate(gene = rownames(.))), by = c("Gene" = "gene"))
```

```{r, echo=FALSE, results='hide'}
gc()
```

## Branch 2

We'll repeat the analysis on the second branch. 

```{r}
ss_pt_2_scaled <- na.omit(ss_pt[, 2]) / max(na.omit(ss_pt[, 2]))
cells_branch_2 <- rownames(ss_pt)[!is.na(ss_pt[, 2])]
sim_counts_2 <- t(counts(panc_sim[, colnames(panc_sim) %in% cells_branch_2]))
sim_counts_2 <- sim_counts_2[, which(colSums(sim_counts_2) > 0)]
sim_counts_2 <- as.matrix(sim_counts_2)
pt_df_2 <- data.frame(PT = ss_pt_2_scaled)
```

```{r, echo=FALSE, results='hide'}
gc()
```

`testDynamic()` fits a `marge` spline-based NB GLM to each gene, using pseudotime as the sole covariate. 

```{r}
gene_stats_2 <- testDynamic(expr = sim_counts_2, 
                            pt = pt_df_2, 
                            genes = colnames(sim_counts_2), # dyn_results_1$Gene, 
                            parallel = TRUE, 
                            n.cores = 2, 
                            track.time = TRUE) 
```

We pull the results from `testDynamic()` into a tidy dataframe. 

```{r}
dyn_results_2 <- getResultsDE(gene_stats_2) %>% 
                 inner_join((rowData(panc_sim) %>% 
                             as.data.frame() %>% 
                             mutate(gene = rownames(.))), by = c("Gene" = "gene"))
```

Next we'll run another test of dynamism (?) with `testSlopes()`. 

```{r}
mod_list_2 <- getModelList(gene_stats_2)
slope_test_2 <- testSlope(model.list = mod_list_2, 
                          pt = pt_df_2, 
                          p.adj.method = "bonferroni", 
                          fdr.cutoff = 0.01)
slope_results_2 <- slope_test_2 %>% 
                   inner_join((rowData(panc_sim) %>% 
                               as.data.frame() %>% 
                               mutate(gene = rownames(.))), by = c("Gene" = "gene"))
```

# Model Performance

## `testDynamic()`

We'll need to combine the results of `testDynamic()` on the two lineages, since some genes may be dynamic in one lineage but not in another.

```{r}
dyn_res_combined <- dyn_results_1 %>% 
                    select(Gene, Model_Status, P_Val_Adj, Gene_Dynamic, geneStatus) %>% 
                    relocate(Gene, geneStatus) %>% 
                    rename(Model_Status_1 = Model_Status, 
                           P_Val_Adj_1 = P_Val_Adj, 
                           Gene_Dynamic_1 = Gene_Dynamic) %>% 
                    left_join((dyn_results_2 %>% 
                               select(Gene, Model_Status, P_Val_Adj, Gene_Dynamic, geneStatus) %>% 
                               relocate(Gene, geneStatus) %>% 
                               rename(Model_Status_2 = Model_Status, 
                                      P_Val_Adj_2 = P_Val_Adj, 
                                      Gene_Dynamic_2 = Gene_Dynamic)), by = c("Gene", "geneStatus")) %>% 
                    mutate(Gene_Dynamic_Both = case_when(Gene_Dynamic_1 == 1 & Gene_Dynamic_2 == 1 ~ 1, TRUE ~ 0), 
                           Gene_Dynamic_One = case_when(Gene_Dynamic_1 == 1 & Gene_Dynamic_2 == 0 ~ 1, 
                                                        Gene_Dynamic_1 == 0 & Gene_Dynamic_2 == 1 ~ 1, 
                                                        TRUE ~ 0))
```

Lastly, let's check some performance metrics for our model. To be categorized as dynamic, a gene must be considered so by the `marge` model on both lineages. 

```{r}
caret::confusionMatrix(data = as.factor(ifelse(dyn_res_combined$geneStatus == "Dynamic", 1, 0)), 
                       reference = as.factor(dyn_res_combined$Gene_Dynamic_Both), 
                       positive = "1")
```

## `testSlope()`

We'll repeat the process with `testSlope()`. 

```{r}
slope_res_combined <- slope_results_1 %>% 
                      select(Gene, geneStatus, Gene_Dynamic) %>% 
                      rename(Gene_Dynamic_1 = Gene_Dynamic) %>% 
                      distinct() %>% 
                      inner_join((slope_results_2 %>% 
                                  select(Gene, geneStatus, Gene_Dynamic) %>% 
                                  rename(Gene_Dynamic_2 = Gene_Dynamic) %>% 
                                  distinct()), by = c("Gene", "geneStatus")) %>% 
                      mutate(Gene_Dynamic_Both = case_when(Gene_Dynamic_1 == 1 & Gene_Dynamic_2 == 1 ~ 1, TRUE ~ 0), 
                            Gene_Dynamic_One = case_when(Gene_Dynamic_1 == 1 & Gene_Dynamic_2 == 0 ~ 1, 
                                                         Gene_Dynamic_1 == 0 & Gene_Dynamic_2 == 1 ~ 1, 
                                                         TRUE ~ 0))
```

And another confusion matrix:

```{r}
caret::confusionMatrix(data = as.factor(ifelse(slope_res_combined$geneStatus == "Dynamic", 1, 0)), 
                       reference = as.factor(slope_res_combined$Gene_Dynamic_Both), 
                       positive = "1")
```

# Save Data 

Lastly, we save everything. 

```{r}
saveRDS(panc_sim, file = paste0("./panc_sim_", gsub("-", "", Sys.Date()), ".Rds"))
saveRDS(gene_stats_1, file = file = paste0("./gene_stats_1_", gsub("-", "", Sys.Date()), ".Rds"))
saveRDS(gene_stats_2, file = file = paste0("./gene_stats_2_", gsub("-", "", Sys.Date()), ".Rds"))
saveRDS(dyn_res_combined, file = paste0("./dyn_res_combined_", gsub("-", "", Sys.Date()), ".Rds"))
saveRDS(slope_res_combined, file = paste0("./slope_res_combined_", gsub("-", "", Sys.Date()), ".Rds"))
```
