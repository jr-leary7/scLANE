---
title: "Identifying Dynamic Genes with Generalized Estimating Equations in `scLANE`"
subtitle: "University of Florida - Dept. of Biostatistics - Bacher Group"
author: "Jack Leary"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: yeti
    highlight: tango
    code_folding: show
    code_download: true
    toc: true
    toc_float:
      collpased: false
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      comment = NA, 
                      message = FALSE, 
                      warning = FALSE, 
                      fig.align = "center")
set.seed(312)  # lucky seed
```

# Introduction 

In this vignette we'll focus on one of the more complicated features of `scLANE`: the usage of GEE models to identify dynamic genes when cells are grouped by some subject identity. The robust variance estimation available in GEE models allows us to make decisions about which genes are actually dynamic over pseudotime / latent time while accounting for intra-subject correlations between observations. The downsides are that the benefits of GEE models can be a little more difficult to explain to collaborators, and they take a little bit longer than GLMs to estimate. A refresher on what GEEs are and why they're useful can be found [here](https://www.publichealth.columbia.edu/research/population-health-methods/repeated-measures-analysis). 

# Libraries

```{r, results='hide'}
library(dplyr)      # data manipulation
library(scran)      # single cell tools 
library(scLANE)     # differential expression over pseudotime
library(scater)     # single cell tools 
library(slingshot)  # pseudotime estimation
```

# Data 

First we'll load in the lung tumor data from [Zilionis *et al* (2019)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6620049/), and subset to only include tumor neutrophils. The authors found 5 continuous tumor neutrophil subsets in their analysis, and we're interested in determining which genes drive subset-to-subset differentiation. The data were collected from 7 different patients, and thus the usage of GEE models is warranted in order to properly estimate within-patient gene expression correlations. Lastly, we'll subset the object to only include genes that are expressed in at least 5 cells. 

```{r}
lung <- scRNAseq::ZilionisLungData(which = "human", filter = TRUE)
lung <- lung[, stringr::str_detect(lung$`Major cell type`, "tNeutrophils")]
lung <- lung[which(rowSums(counts(lung) > 0) >= 5), ]
```

## Preprocessing

First we'll preprocess the data in the typical way. We see that the neutrophils fall into 5 clusters, and that there is one odd outlier group of cells near the top of the UMAP plot. In addition, there is a decent amount of intra- and inter-patient variability. The cluster labels are not solely reflective of the cell subtypes, and seem to be driven by both patient identity as well as cell subtype. 

```{r}
lung <- logNormCounts(lung)
var_decomp <- modelGeneVar(lung)
top2k_hvgs <- getTopHVGs(var_decomp, n = 2000)
lung <- runPCA(lung, subset_row = top2k_hvgs)
reducedDim(lung, "PCAsub") <- reducedDim(lung, "PCA")[, 1:10, drop = FALSE]
lung <- runUMAP(lung, dimred = "PCAsub", n_dimred = 1:10)
g <- buildSNNGraph(lung, use.dimred = "PCAsub", k = 20)
clusters <- igraph::cluster_louvain(graph = g)$membership
colLabels(lung) <- factor(clusters)
plotUMAP(lung, colour_by = "label")
plotUMAP(lung, colour_by = "Patient")
plotUMAP(lung, colour_by = "Minor subset")
```

## Estimating Pseudotime

We'll use `slingshot` to estimate a pseudotime value for each cell. In this case, we see only one pseudotime lineage. 

```{r}
scl_lineage <- getLineages(reducedDim(lung, "PCAsub"), clusterLabels = clusters)
scl_crv <- getCurves(scl_lineage)
scl_cell_weights <- slingCurveWeights(scl_crv)
scl_pt <- slingPseudotime(scl_crv)
pt_df <- as.data.frame(scl_pt) %>% 
         mutate(across(everything(), function(x) x / max(x, na.rm = TRUE)))
```

# Running `scLANE` 

## Global Test

We're going to run `scLANE` solely on the top 100 most highly variable genes. This is for both computational quickness & in order to get interesting results (highly variable oftentimes $\implies$ dynamic), as this is a just a tutorial. Note that we need to provide a (sorted) vector of subject IDs as well as a working correlation structure. In this case we opt for the default exchangeable (AKA compound symmetry) structure, as it stands to reason that within-subject cells will have similar correlations. 

```{r}
lung_counts <- as.matrix(t(lung@assays@data$counts))[, top2k_hvgs[1:100]]
gene_stats <- testDynamic(expr.mat = lung_counts, 
                          pt = pt_df, 
                          is.gee = TRUE, 
                          id.vec = lung$Patient, 
                          cor.structure = "exchangeable", 
                          n.potential.basis.fns = 4, 
                          parallel.exec = TRUE, 
                          n.cores = 6, 
                          track.time = TRUE)
```

Let's check out the results of the global differential expression test. 

```{r}
getResultsDE(gene_stats) %>% 
  select(-contains("LogLik"), -contains("Dev")) %>%  # log-likelihood & deviance not computed for GEEs
  arrange(Gene, Lineage) %>% 
  slice_head(n = 10) %>% 
  kableExtra::kbl(digits = 5, 
                  align = "c", 
                  booktabs = TRUE, 
                  caption = "Lineage-level dynamic test", 
                  col.names = c("Gene", "Lineage", "Test Stat.", "P-value", "Test Stat. Type", "Test Notes", 
                                "Model Status", "Adj. P-value", "Gene Dynamic over Lineage", "Gene Dynamic")) %>% 
  kableExtra::kable_paper("hover", full_width = FALSE)
```

## Slope Test 

Next we can run the slope test to identify over which pseudotime intervals gene expression changes significantly. 

```{r}
testSlope(test.dyn.results = gene_stats) %>% 
  slice_head(n = 10) %>% 
  kableExtra::kbl(digits = 5, 
                  align = "c", 
                  booktabs = TRUE, 
                  caption = "Slope-level dynamic test", 
                  col.names = c("Gene", "Lineage", "Breakpoint", "Rounded Breakpoint", 
                                "Direction", "P-value", "Notes", "Adj. P-value", 
                                "Gene Dynamic over Lineage/Interval", "Gene Dynamic over Lineage", 
                                "Gene Dynamic")) %>% 
  kableExtra::kable_paper("hover", full_width = FALSE)
```

## Model Visualization 

Lastly, we can plot the fitted models for a couple of the genes. In addition to the null (intercept-only) and `MARGE` models we can also compare to a GEE GLM with pseudotime as a covariate. 

```{r, fig.width=4}
plotModels(test.dyn.res = gene_stats, 
           gene = "CXCL8", 
           pt = pt_df, 
           gene.counts = lung_counts, 
           is.gee = TRUE, 
           id.vec = lung$Patient, 
           cor.structure = "exchangeable")
plotModels(test.dyn.res = gene_stats, 
           gene = "RGS2", 
           pt = pt_df, 
           gene.counts = lung_counts, 
           is.gee = TRUE, 
           id.vec = lung$Patient, 
           cor.structure = "exchangeable")
```

## Gene-level Analysis 

Let's cluster the genes based on their fitted values using hierarchical clustering with Ward's linkage. 

```{r, fig.width=9}
gene_clusters <- clusterGenes(gene_stats, clust.algo = "hclust")
plot_data <- plotClusteredGenes(test.dyn.results = gene_stats, 
                                gene.clusters = gene_clusters, 
                                pt = pt_df)
```

We'll plot the gene cluster data using `ggplot2`:

```{r, fig.width=9}
ggplot(plot_data, aes(x = PT, y = FITTED, color = CLUSTER, group = GENE)) + 
  facet_wrap(~paste0("Lineage ", LINEAGE) + paste0("Cluster ", CLUSTER)) + 
  geom_line() + 
  scale_color_manual(values = c("firebrick", "forestgreen", "steelblue3")) + 
  labs(x = "Pseudotime", 
       y = "Fitted Values", 
       color = "Leiden\nCluster", 
       title = "Unsupervised Clustering of Gene Patterns") + 
  theme_classic(base_size = 14) + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  guides(color = guide_legend(override.aes = list(size = 2)))
```

# Session Info 

```{r}
sessioninfo::session_info()
```
