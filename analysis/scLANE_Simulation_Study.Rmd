---
title: "scLANE_Simulation_Study"
subtitle: "University of Florida Dept. of Biostatistics - The Bacher Group"
author: "Jack Leary"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{scLANE_Simulation_Study}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE, 
  message = FALSE, 
  comment = "#>"
)
```

```{r setup}
library(dplyr)
library(scran)
library(scater)
library(scLANE)
library(ggplot2)
library(scaffold)
library(slingshot)
library(kableExtra)
library(SingleCellExperiment)
select <- dplyr::select
rename <- dplyr::rename
```

# Simulation with `scaffold`

First we'll use [Dr. Ronda Bacher's `scaffold` package](https://github.com/rhondabacher/scaffold/) to simulate scRNA-seq data with trajectories. The practical advantages of `scaffold` are that it bases its simulated data on real datasets, it generates large numbers of cells and features relatively quickly, and it includes an indicator variable that specifies whether genes are differentially expressed. This last feature will allow us to test the performance of `scLANE` with respect to its identification of genes that are dynamic over pseudotime. Let's dive in!

Before all else one must `set.seed()`.

```{r}
set.seed(312)
RcppZiggurat::zsetseed(312)
```

Let's load in some data. We're going to base our simulation on the data from [Baron *et al* (2016)](https://doi.org/10.1016/j.cels.2016.08.011); their dataset is a small-ish single cell atlas of normal pancreas cells.

```{r}
panc <- scRNAseq::BaronPancreasData()  # uses inDrop, a droplet-based tech
```

And now let's run `scaffold`. We want to generate a UMI-based 10X dataset with 3,000 cells, and `r ceiling(.15 * nrow(panc))` dynamic genes - 15% of the `r nrow(panc)` total genes in the Baron pancreas dataset.

```{r}
n_dyn_genes <- ceiling(.15 * nrow(panc))
myknots <- matrix(runif(2 * n_dyn_genes, 0, 1), ncol = 2, nrow = n_dyn_genes)
mytheta <- matrix(rnorm(5, 5, 5), ncol = 5, nrow = n_dyn_genes)
dynamic_params <- list(propGenes = 0.15,
                       degree = 2,
                       knots = myknots,
                       theta = mytheta)
scaffold_params <- estimateScaffoldParameters(sce = panc,
                                              sceUMI = TRUE,
                                              useUMI = TRUE,
                                              protocol = "droplet",
                                              numCells = 3000,
                                              popHet = c(1, 1),
                                              useDynamic = dynamic_params)
panc_sim <- simulateScaffold(scaffoldParams = scaffold_params, originalSCE = panc)
```

```{r, echo=FALSE, results='hide'}
rm(panc); gc()
```

# Data Pre-processing 

Next we'll need to pre-process the raw counts in the typical way. 

```{r}
panc_sim <- logNormCounts(panc_sim)
var_decomp <- modelGeneVar(panc_sim)
top2k_hvgs <- getTopHVGs(var_decomp, n = 2000)
panc_sim <- runPCA(panc_sim, subset_row = top2k_hvgs)
reducedDim(panc_sim, "PCAsub") <- reducedDim(panc_sim, "PCA")[, 1:10, drop = FALSE]
panc_sim <- runUMAP(panc_sim, dimred = "PCAsub", n_dimred = 1:10)
g <- buildSNNGraph(panc_sim, use.dimred = "PCAsub", k = 30)
clusters <- igraph::cluster_louvain(graph = g)$membership
colLabels(panc_sim) <- factor(clusters)
plotPCA(panc_sim, colour_by = "label")
plotUMAP(panc_sim, colour_by = "label")
```

```{r, echo=FALSE, results='hide'}
panc_sim <- readRDS("~/Desktop/panc_sim.Rds")
gc()
```

# Identifying Dynamic Genes with `scLANE` 

First we'll need to correctly format our data for testing - we need a matrix of integer counts, and a dataframe of cell orderings (pseudotime, latent time, etc.). 

```{r}
colData(panc_sim) <- colData(panc_sim) %>% 
                     as.data.frame() %>% 
                     mutate(cell_time = as.numeric(gsub("Cell_", "", rownames(.))), 
                            cell_time_normed = cell_time / max(cell_time)) %>% 
                     DataFrame()
sim_counts <- as.matrix(t(counts(panc_sim)))
sim_counts <- sim_counts[, which(colSums(sim_counts) > 0)]
pt_df <- colData(panc_sim) %>% 
         as.data.frame() %>% 
         select(cell_time_normed) %>% 
         rename(PT = cell_time_normed)
```

We use `testDynamic()` to fit a `marge` model to each gene with a maximum of $k = 5$ breakpoints. Then, we'll check the categorization of each gene as dynamic versus the ground truth labels from `scaffold`. 

```{r}
start_time_scl <- Sys.time()
gene_stats <- testDynamic(expr.mat = sim_counts, 
                          pt = pt_df, 
                          parallel.exec = TRUE, 
                          n.cores = 4, 
                          n.potential.basis.fns = 5, 
                          track.time = TRUE)
global_test_results <- getResultsDE(gene_stats, p.adj.method = "bonferroni", fdr.cutoff = 0.01) %>% 
                       inner_join((rowData(panc_sim) %>% 
                                   as.data.frame() %>% 
                                   mutate(gene = rownames(.))), by = c("Gene" = "gene"))
end_time_scl <- Sys.time()
end_time_scl - start_time_scl
```

Next we'll run another test of dynamism (?) with `testSlopes()`. 

```{r}
slope_test <- testSlope(test.dyn.results = gene_stats, 
                        p.adj.method = "bonferroni", 
                        fdr.cutoff = 0.01)
slope_test_results <- slope_test %>% 
                      inner_join((rowData(panc_sim) %>% 
                                  as.data.frame() %>% 
                                  mutate(gene = rownames(.))), by = c("Gene" = "gene"))
```

```{r, echo=FALSE, results='hide'}
gc()
```

# Model Performance

## `tradeSeq`

We use `tradeSeq()` to generate a NB-GAM for each gene, i.e., the same model form that we used in `testDynamic()` and `testSlope()`. 

```{r}
library(tradeSeq)
start_time <- Sys.time()
trade_sce <- fitGAM(counts = counts(panc_sim), 
                    pseudotime = pt_df$PT, 
                    cellWeights = rep(1, nrow(pt_df)), 
                    nknots = 6, 
                    verbose = FALSE, 
                    parallel = TRUE)
ts_asso_test <- associationTest(trade_sce) %>% 
                arrange(pvalue) %>% 
                mutate(pvalue_adj = p.adjust(pvalue, method = "bonferroni"), 
                       Gene_Dynamic = case_when(pvalue_adj < 0.01 ~ 1, TRUE ~ 0), 
                       geneStatus = (rowData(panc_sim) %>% as.data.frame() %>% pull(geneStatus)))
end_time <- Sys.time()
end_time - start_time
```

The results of `tradeSeq()` aren't incredible. The sensitivity is very low, and the accuracy is lower than the NIR. 

```{r}
caret::confusionMatrix(data = as.factor(ifelse(ts_asso_test$geneStatus == "Dynamic", 1, 0)), 
                       reference = as.factor(ts_asso_test$Gene_Dynamic), 
                       positive = "1", 
                       mode = "everything")
```

Let's check out the AUC-ROC curve. 

```{r}
roc_df_ts <- yardstick::roc_curve((ts_asso_test %>% mutate(geneStatus = as.factor(geneStatus))), 
                                  truth = geneStatus, 
                                  estimate = pvalue, 
                                  event_level = "second")
roc_auc_ts <- yardstick::roc_auc((ts_asso_test %>% mutate(geneStatus = as.factor(geneStatus))), 
                                 truth = geneStatus, 
                                 estimate = pvalue, 
                                 event_level = "second")
ggplot(roc_df_ts, aes(x = 1 - specificity, y = sensitivity)) + 
  geom_line(color = "forestgreen", size = 1) + 
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = "firebrick", size = 1) + 
  labs(x = "1 - Specificity", 
       y = "Sensitivity", 
       title = "tradeSeq", 
       caption = paste0("AUC-ROC = ", round(roc_auc_ts[1, 3], 2))) + 
  theme_classic(base_size = 22) + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"), 
        plot.title.position = "plot")
```

## `testDynamic()`

Lastly, let's check some performance metrics for our model. First we'll check the global LRT as performed in `testDynamic()`. The sensitivity and specificity are both very high!

```{r}
caret::confusionMatrix(data = as.factor(ifelse(global_test_results$geneStatus == "Dynamic", 1, 0)), 
                       reference = as.factor(global_test_results$Gene_Dynamic_Overall), 
                       positive = "1", 
                       mode = "everything")
```

We can also calculate the ROC-AUC based on different thresholds of the adjusted $p$-value. 

```{r}
roc_df <- yardstick::roc_curve((global_test_results %>% mutate(geneStatus = as.factor(geneStatus))), 
                               truth = geneStatus, 
                               estimate = P_Val, 
                               event_level = "second")
roc_auc <- yardstick::roc_auc((global_test_results %>% mutate(geneStatus = as.factor(geneStatus))), 
                              truth = geneStatus, 
                              estimate = P_Val, 
                              event_level = "second")
ggplot(roc_df, aes(x = 1 - specificity, y = sensitivity)) + 
  geom_line(color = "forestgreen", size = 1) + 
  geom_segment(aes(x = 0, y = 0, xend = 1, yend = 1), color = "firebrick", size = 1) +
  scale_x_continuous(labels = scales::number_format(accuracy = 0.1)) + 
  scale_y_continuous(labels = scales::number_format(accuracy = 0.1)) + 
  labs(x = "1 - Specificity", 
       y = "Sensitivity", 
       title = "scLANE", 
       caption = paste0("AUC-ROC = ", round(roc_auc[1, 3], 2))) + 
  theme_classic(base_size = 22) + 
  theme(plot.title = element_text(hjust = 0.5, face = "bold"), 
        plot.title.position = "plot")
```

## `testSlope()`

We'll generate the same confusion matrix for the results from `testSlope()`. The results are pretty similar to those of `testDynamic()`, which we expect. 

```{r}
slope_test_sum <- slope_test_results %>% 
                  select(Gene, Gene_Dynamic_Overall, geneStatus) %>% 
                  distinct()
caret::confusionMatrix(data = as.factor(ifelse(slope_test_sum$geneStatus == "Dynamic", 1, 0)), 
                       reference = as.factor(slope_test_sum$Gene_Dynamic), 
                       positive = "1", 
                       mode = "everything")
```

# Conclusions

In general, it looks as though `scLANE` outperforms `tradeSeq` in terms of accurately and precisely determining which genes are significantly differentially expressed over pseudotime. 

# Visualization 

Here's how we can plot model results using the `plotModels()` function. 

```{r}
library(glm2)
plotModels(test.dyn.res = gene_stats, 
           gene = "MNX1", 
           pt = pt_df, 
           gene.counts = sim_counts)
```

# Session Info

```{r}
sessioninfo::session_info()
```
