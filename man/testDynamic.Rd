% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/testDynamic.R
\name{testDynamic}
\alias{testDynamic}
\title{Test whether a gene is dynamic over pseudotime.}
\usage{
testDynamic(
  expr.mat = NULL,
  pt = NULL,
  genes = NULL,
  n.potential.basis.fns = 5,
  size.factor.offset = NULL,
  is.gee = FALSE,
  cor.structure = "ar1",
  is.glmm = FALSE,
  glmm.adaptive = FALSE,
  id.vec = NULL,
  parallel.exec = TRUE,
  n.cores = 2,
  approx.knot = TRUE,
  track.time = FALSE,
  random.seed = 312
)
}
\arguments{
\item{expr.mat}{Either a \code{SingleCellExperiment} or \code{Seurat} object from which counts can be extracted, or a matrix of integer-valued counts with genes as rows & cells as columns. Defaults to NULL.}

\item{pt}{Either the output from \code{\link[slingshot]{SlingshotDataSet}} object from which pseudotime can be generated, or a data.frame containing the pseudotime or latent time estimates for each cell (can be multiple columns / lineages). Defaults to NULL.}

\item{genes}{A character vector of genes to model. If not provided, defaults to all genes in \code{expr.mat}. Defaults to NULL.}

\item{n.potential.basis.fns}{(Optional) The maximum number of possible basis functions. See the parameter \code{M} in \code{\link{marge2}}. Defaults to 5.}

\item{size.factor.offset}{(Optional) An offset to be included in the final model fit. Can be generated easily with \code{\link{createCellOffset}}. Defaults to NULL.}

\item{is.gee}{Should a GEE framework be used instead of the default GLM? Defaults to FALSE.}

\item{cor.structure}{If the GEE framework is used, specifies the desired working correlation structure. Must be one of "ar1", "independence", or "exchangeable". Defaults to "ar1".}

\item{is.glmm}{Should a GLMM framework be used instead of the default GLM? Defaults to FALSE.}

\item{glmm.adaptive}{(Optional) Should the basis functions for the GLMM be chosen adaptively? If not, uses 4 evenly spaced knots. Defaults to FALSE.}

\item{id.vec}{If a GEE or GLMM framework is being used, a vector of subject IDs to use as input to \code{\link[geeM]{geem}} or \code{\link[glmmTMB]{glmmTMB}}. Defaults to NULL.}

\item{parallel.exec}{A boolean indicating whether a parallel \code{\link[foreach]{foreach}} loop should be used to generate results more quickly. Defaults to TRUE.}

\item{n.cores}{(Optional) If running in parallel, how many cores should be used? Defaults to 2.}

\item{approx.knot}{(Optional) Should the knot space be reduced in order to improve computation time? Defaults to TRUE.}

\item{track.time}{(Optional) A boolean indicating whether the amount of time the function takes to run should be tracked and printed to the console. Useful for debugging. Defaults to FALSE.}

\item{random.seed}{(Optional) The random seed used to initialize RNG streams in parallel. Defaults to 312.}
}
\value{
A list of lists, where each element is a gene and each gene contains sublists for each element. Each gene-lineage sublist contains a gene name, lineage number, default \code{marge} vs. null model test results, model statistics, and fitted values. Use \code{\link{getResultsDE}} to tidy the results.
}
\description{
This function tests whether a NB \code{marge} model is better than a null (intercept-only) NB GLM using the Likelihood Ratio Test. In effect, the test tells us whether a gene's expression changes (in any way) over pseudotime.
}
\details{
\itemize{
\item If \code{expr.mat} is a \code{Seurat} object, counts will be extracted from the output of \code{\link[SeuratObject]{DefaultAssay}}. If using this functionality, check to ensure the specified assay is correct before running the function. If the input is a \code{SingleCellExperiment} object, the raw counts will be extracted with \code{\link[BiocGenerics]{counts}}.
\item If using the GEE or GLMM model architectures, ensure that the observations are sorted by subject ID (this is assumed by the underlying fit implementations). If they are not, the models will error out.
}
}
\examples{
\dontrun{
testDynamic(expr.mat = raw_counts,
            pt = pseudotime_df,
            parallel.exec = TRUE)
testDynamic(expr.mat = sce_obj,
            pt = slingshot_obj,
            size.factor.offset = sizeFactors(sce_obj),
            genes = rownames(sce_obj)[1:100])
testDynamic(expr.mat = raw_counts,
            pt = pseudotime_df,
            parallel.exec = TRUE,
            n.cores = 8,
            n.potential.basis.fns = 7)
testDynamic(expr.mat = counts(sce_obj),
            pt = pseudotime_df,
            is.gee = TRUE,
            id.vec = colData(sce_obj)$subject_id,
            cor.structure = "ar1",
            parallel.exec = TRUE,
            n.cores = 8,
            n.potential.basis.fns = 7)
testDynamic(expr.mat = seu_obj,
            pt = pseudotime_df,
            parallel.exec = TRUE,
            n.cores = 8,
            is.glmm = TRUE,
            id.vec = seu_obj$subject_id)
}
}
\seealso{
\code{\link{getResultsDE}}

\code{\link{testSlope}}

\code{\link{marge2}}

\code{\link[MASS]{glm.nb}}

\code{\link[geeM]{geem}}

\code{\link[glmmTMB]{glmmTMB}}
}
\author{
Jack Leary
}
